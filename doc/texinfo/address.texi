@example
@code{/* Prefix @emph{address_} is reserved */}
@code{#include <mailutils/address.h>}

@end example
The Internet address format is defined in RFC 822. RFC 822 has been
updated, and is now superceeded by RFC 2822, which
makes some corrections and clarifications. References to RFC 822
here apply equally to RFC 2822.

The RFC 822 format is more flexible than many people realize, here
is a quick summary of the syntax this parser implements, see
RFC 822 for the details. "[]" pairs mean "optional", "/" means "one or
the other", and double-quoted characters are literals.

@example
addr-spec    = local-part "@" domain
mailbox      = addr-spec ["(" display-name ")"] /
               [display-name] "<" [route] addr-spec ">"
mailbox-list = mailbox ["," mailbox-list]
group        = display-name ":" [mailbox-list] ";"
address      = mailbox / group / unix-mbox
address-list = address ["," address-list]
@end example

unix-mbox is a non-standard extension meant to deal with the common
practice of using user names as addresses in mail utilities. It allows
addresses such as "root" to be parsed correctly. These are NOT valid
internet email addresses, they must be qualified before use.

Several address functions have a set of common arguments with consistent
semantics, these are described here to avoid repetition.

Since an address-list may contain multiple addresses, they are accessed
by a @strong{one-based} index number, @var{no}. The index is one-based
because pop, imap, and other message stores commonly use one-based
counts to access messages and attributes of messages.

If @var{len} is greater than @code{0} it is the length of the buffer
@var{buf}, and as much of the component as possible will be copied
into the buffer. The buffer will be null terminated.

The size of a particular component may be queried by providing @code{0}
for the @var{len} of the buffer, in which case the buffer is optional.
In this case, if @var{n} is provided *@var{n} is assigned the length of
the component string.

@macro ADDRESSENOMEM
@item ENOMEM
Not enough memory to allocate resources.
@end macro

@macro ADDRESSEPARSE
@item ENOENT
Invalid RFC822 syntax, parsing failed.
@end macro

@macro ADDRESSENOENT
@item ENOENT
The index @var{no} is outside of the range of available addresses.
@end macro

@macro ADDRESSEINVAL
@item EINVAL
Invalid usage, usually a required argument was @code{null}.
@end macro

@deftp {Data Type} address_t
The @code{address_t} object is used to hold information about a parsed
RFC822 address list, and is an opaque
data structure to the user. Functions are provided to retrieve information
about an address in the address list.

@end deftp

@deftypefun int address_create (address_t *@var{addr}, const char *@var{string})
This function allocates and initializes @var{addr} by parsing the
RFC822 address-list @var{string}.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOMEM
@ADDRESSEPARSE
@end table
@end deftypefun

@deftypefun int address_createv (address_t *@var{addr}, const char *@var{sv}, size_t @var{len})
This function allocates and initializes @var{addr} by parsing the
array of pointers to RFC822 address-lists in @var{sv}. If @var{len} is
@code{-1}, then @var{sv} must be null-terminated in the fashion of @var{argv},
otherwise @var{len} is the length of the array.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOMEM
@ADDRESSEPARSE
@end table
@end deftypefun




@deftypefun  void address_destroy (address_t *@var{addr})
The @var{addr} is destroyed.
@end deftypefun

@deftypefun  int address_get_email (address_t *@var{addr}, size_t @var{no}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Accesses the @var{no}th email address component of the address list. This
address is the plain email address, correctly quoted, suitable for
using in an smtp dialog, for example, or as the address part of
a contact book entry.

Note that the entry may be valid, but be a group name. In this case success
is returned, but the length of the address is @code{0}.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun

@deftypefun  int address_aget_email (address_t *@var{addr}, size_t @var{no}, char** @var{bufp})

As above, but mallocs the email address, if present,

and write a pointer to it into @var{bufp}. @var{bufp} will be @code{NULL}
if there is no email address to return.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun

@deftypefun  int address_get_personal (address_t *@var{addr}, size_t @var{no}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Accesses the display-name describing the @var{no}th email address. This
display-name is optional, so may not be present. If it is not present, but
there is an RFC822 comment after the address, that comment will be
returned as the personal phrase, as this is a common usage of the comment
even though it is not defined in the internet mail standard.

A group is a kind of a special case. It has a display-name, followed
by an optional mailbox-list. The display-name will be allocated an address
all it's own, but all the other elements (local-part, domain, etc.) will
be zero-length. So "a group: ;" is valid, will have a count of 1, but
address_get_email(), and all the rest, will return zero-length output.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun


@deftypefun  int address_get_comments (address_t *@var{addr}, size_t @var{no}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Accesses the comments extracted while parsing the @var{no}th email address.
These comments have no defined meaning, and are not currently collected.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun


@deftypefun  int address_get_email (address_t *@var{addr}, size_t @var{no}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Accesses the email addr-spec extracted while
parsing the @var{no}th email address. This will be @code{0}
length for a unix-mbox.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun

@deftypefun  int address_get_local_part (address_t *@var{addr}, size_t @var{no}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Accesses the local-part of an email addr-spec extracted while
parsing the @var{no}th email address.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun

@deftypefun  int address_get_domain (address_t *@var{addr}, size_t @var{no}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Accesses the domain of an email addr-spec extracted while
parsing the @var{no}th email address. This will be @code{0}
length for a unix-mbox.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun

@deftypefun  int address_get_route (address_t *@var{addr}, size_t @var{no}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Accesses the route of an email addr-spec extracted while
parsing the @var{no}th email address. This is a rarely used RFC822 address
syntax, but is legal in SMTP as well. The entire route is returned as
a string, those wishing to parse it should look at <mailutils/parse822.h>.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun

@deftypefun  int address_is_group (address_t *@var{addr}, size_t @var{no}, size_t @var{len}, int* @var{yes})

Sets *@var{yes} to @code{1} if this address is just the name of a group,
@code{0} otherwise. This is faster than checking if the address has
a non-zero length personal, and a zero-length local_part and domain.

@var{yes} can be @code{null}, though that doesn't serve much purpose other
than determining that @var{no} refers to an address.

Currently, there is no way to determine the end of the group.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOENT
@end table
@end deftypefun

@deftypefun  int address_to_string (address_t *@var{addr}, char* @var{buf}, size_t @var{len}, size_t* @var{n})

Returns the entire address list as a single RFC822 formatted address
list.

The return value is @code{0} on success and a code number on error conditions:
@table @code
@ADDRESSEINVAL
@ADDRESSENOMEM
@end table
@end deftypefun


@deftypefun  int address_get_count (address_t @var{addr}, size_t* @var{count})

Returns a count of the addresses in the address list.

If @var{addr} is @code{null}, the count is @code{0}. If @var{count} is
not @code{null}, the count will be written to *@var{count}.

The return value is @code{0}.
@end deftypefun

@section Example
@example
@include ex-address.texi
@end example

