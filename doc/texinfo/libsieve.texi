@c This is part of the GNU Mailutils manual.
@c Copyright (C) 1999,2000,2001,2002 Free Software Foundation, Inc.
@c See file mailutils.texi for copying conditions.
@comment *******************************************************************

This chapter describes @sc{gnu} Sieve library.

@menu
* Library Description::
* Input Language::
* Extensions::
* Writing Loadable Commands::
@end menu

@node Library Description
@section Library Description

@code{Libsieve} is @sc{gnu} implementation of the mail filtering
language Sieve.

The library is built around a @dfn{Sieve Machine} --- an abstract
computer constructed specially to handle mail filtering tasks. This
computer has two registers: program counter and numeric accumulator;
a runtime stack of unlimited depth and the code segment. A set of
functions is provided for creating and destroying instances of Sieve
Machine, manipulating its internal data, compiling and executing a
sieve program.

The following is a typical scenario of using @code{libsieve}:

@enumerate
@item Application program creates the instance of sieve machine.

@item Then @code{sieve_compile} function is called to translate
the Sieve source into an equivalent program executable by the
Machine

@item A mailbox is opened and associated with the Machine

@item The Machine executes the program over the mailbox

@item When the execution of the program is finished, all messages upon which
an action was executed other than @code{keep} are marked with the delete
flag. Thus, running @code{mailbox_expunge} upon the mailbox finishes
the job, leaving in the mailbox only those messages that were preserved
by the filter.

@item Finally, the instance of Sieve Machine is destroyed and the
resources allocated for it are reclaimed.

@end enumerate

The following sections describe in detail the functions from the
Sieve Library.

@menu
* Sieve Data Types::
* Manipulating the Sieve Machine::
* Logging and Diagnostic Functions::
* Symbol Space Functions::
* Memory Allocation::
* Compiling and Executing the Script::
@end menu

@node Sieve Data Types
@subsection Sieve Data Types

@deftp {Data Type} sieve_machine_t
This is an opaque data type representing a pointer to an instance of
sieve machine. The sieve_machine_t keeps all information necessary
for compiling and executing the script.

It is created by @code{sieve_machine_create()} and destroyed by
@code{sieve_machine_destroy()}. The functions for manipulating this data
type are described in @ref{Manipulating the Sieve Machine}.
@end deftp

@deftp {Enumeration} sieve_data_type
This enumeration keeps the possible types of sieve data. These are:

@table @code
@item SVT_VOID
No datatype.

@item SVT_NUMBER
Numeric type.

@item SVT_STRING
Character string.

@item SVT_STRING_LIST
A @code{list_t}. Each item in this list represents a character string.

@item SVT_TAG
A sieve tag. See @code{sieve_runtime_tag_t} below.

@item SVT_IDENT
A character string representing an identifier. 

@item SVT_VALUE_LIST
A @code{list_t}. Each item in this list is of @code{sieve_value_t}.

@item SVT_POINTER
An opaque pointer.
@end table
@end deftp

@deftp {Structure} sieve_value_t
The @code{sieve_value_t} keeps an instance of sieve data. It is defined
as follows:

@example
@group
typedef struct @{
  sieve_data_type type;        /* Type of the data */
  union @{
    char *string;              /* String value or identifier */
    long number;               /* Numeric value */
    list_t list;               /* List value */
    sieve_runtime_tag_t *tag;  /* Tag value */
    void *ptr;                 /* Pointer value */ 
  @} v;
@} sieve_value_t;
@end group
@end example

Depending on the value of @code{type} member, following members of the
union @code{v} keep the actual value:

@table @code
@item SVT_VOID
Never appears.

@item SVT_NUMBER
The numeric value is kept in @code{number} member.

@item SVT_STRING
The string is kept in @code{string} member.

@item SVT_STRING_LIST
@itemx SVT_VALUE_LIST
The list itself is pointed to by @code{list} member

@item SVT_TAG
The tag value is pointed to by @code{tag} member.

@item SVT_IDENT
The @code{string} member points to the identifier name.

@item SVT_POINTER
The data are pointed to by @code{ptr} member.
@end table

@end deftp

@deftp {Structure} sieve_tag_def_t
This structure represents a definition of a tagged (optional) argument
to a sieve action or test. It is defined as follows:

@example
@group
typedef struct @{
  char *name;              /* Tag name */
  sieve_data_type argtype; /* Type of tag argument. */
@} sieve_tag_def_t;
@end group
@end example

The @code{name} member points to the tag's name @emph{without leading
colon}. The @code{argtype} is set to @code{SVT_VOID} if the tag does
not take argument, or to the type of the argument otherwise.
@end deftp

@deftp {Structure} sieve_runtime_tag_t
This structure represents the tagged (optional) argument at a runtime.
It is defined as:

@example
@group
struct sieve_runtime_tag @{
  char *tag;                /* Tag name */
  sieve_value_t *arg;       /* Tag argument (if any) */
@};
@end group
@end example

The @code{arg} member is @code{NULL} if the tag does not take an argument.
@end deftp

@deftp {Function Type} sieve_handler_t

This is a pointer to function handler for a sieve action or test.
It is defined as follows:
@example
typedef int (*sieve_handler_t) (sieve_machine_t @var{mach},
                                list_t @var{args}, list_t @var{tags});
@end example
@end deftp

The arguments to the handler have the following meaning:

@table @var
@item mach
Sieve machine being processed.
@item args
A list of required arguments to the handler
@item tags
A list of optional arguments (tags).
@end table

@deftp {Function Type} sieve_printf_t
A pointer to a diagnostic output function. It is defined as follows:
@example
typedef int (*sieve_printf_t) (void *@var{data}, const char *@var{fmt}, va_list @var{ap});
@end example
@end deftp

@table @var
@item data
A pointer to application specific data. These data are passed as 
second argument to @code{sieve_machine_init()}.
@item fmt
Printf-like format string.
@item ap
Other arguments.
@end table

@deftp {Function Type} sieve_parse_error_t
This data type is declared as follows:
@example
typedef int (*sieve_parse_error_t) (void *@var{data},
                                    const char *@var{filename}, int @var{lineno},
                                    const char *@var{fmt}, va_list @var{ap});
@end example
@end deftp

It is used to declare error handlers for parsing errors. The
application-specific data are passed in the @var{data}
argument. Arguments @var{filename} and @var{line} indicate the location
of the error in the source text, while @var{fmt} and @var{ap} give
verbose description of the error.

@deftp {Function Type} sieve_action_log_t
A pointer to the application-specific logging function:

@example
typedef void (*sieve_action_log_t) (void *@var{data},
                                    const char *@var{script},
                                    size_t @var{msgno}, message_t @var{msg},
                                    const char *@var{action},
                                    const char *@var{fmt}, va_list @var{ap});
@end example
@end deftp

@table @var
@item data
Application-specific data.

@item script
Name of the sieve script being executed.

@item msgno
Ordinal number of the message in mailbox, if appropriate. When execution
is started using @code{sieve_message()}, this argument is zero.

@item msg
The message this action is executed upon.

@item action
The name of the action.

@item fmt
@itemx var
These two arguments give the detailed description of the action.
@end table

@deftp {Function Type} sieve_comparator_t
@example
typedef int (*sieve_comparator_t) (const char *, const char *);
@end example

A pointer to the comparator handler function. The function compares
its two operands and returns 1 if they are equal, and 0 otherwise.
@emph{Notice}, that the sense of the return value is inverted
in comparison with most standard libc functions like @code{stcmp()}, etc.

@end deftp

@deftp {Function Type} sieve_retrieve_t
@example
typedef int (*sieve_retrieve_t) (void *item, void *data, int idx,
                                 char **pval);
@end example

A pointer to generic retriever function. See description of
@code{sieve_vlist_compare()} for details of its usage.
@end deftp

@deftp {Function Type} sieve_destructor_t
@example
typedef void (*sieve_destructor_t) (void *data);
@end example

A pointer to destructor function. The function frees any resources
associated with @code{data}. See the description of
@code{sieve_machine_add_destructor()} for more information.
@end deftp

@deftp {Function Type} sieve_tag_checker_t
@example
typedef int (*sieve_tag_checker_t) (const char *@var{name}, list_t @var{tags}, list_t @var{args})
@end example

A pointer to tag checker function. The purpose of the function is to
perform compilation-time consistency test on tags. Its arguments are:

@table @var
@item name
Name of the test or action whose tags are being checked.

@item tags
A list of @code{sieve_runtime_tag_t} representing tags.

@item args
A list of @code{sieve_value_t} representing required arguments to
@var{name}.
@end table

The function is allowed to make any changes in @var{tags} and
@var{args}. It should return 0 if the syntax is correct and non-zero
otherwise. It is responsible for issuing the diagnostics in the latter
case. [FIXME: describe how to do that]

@end deftp

@node Manipulating the Sieve Machine
@subsection Manipulating the Sieve Machine

This subsection describes functions used to create an instance of the
sieve machine, read or alter its internal fields and destroy it.

@deftypefn int sieve_machine_init (sieve_machine_t *@var{mach}, void *@var{data})

The @code{sieve_machine_init()} function creates an instance of a sieve
machine. A pointer to the instance itself is returned in the argument
@var{mach}. The user-specific data to be associated with the new machine
are passed in @var{data} argument. The function returns 0 on success,
non-zero error code otherwise,
@end deftypefn

@deftypefn void sieve_machine_destroy (sieve_machine_t *@var{pmach})

This function destroys the instance of sieve machine pointed to by
@var{mach} parameter. After execution of @code{sieve_machine_destroy()}
@var{pmach} contains @code{NULL}. The destructors registered with
@code{sieve_machine_add_destructor()} are executed in @sc{lifo}
order.
@end deftypefn

@deftypefn int sieve_machine_add_destructor (sieve_machine_t @var{mach}, sieve_destructor_t @var{destr}, void *@var{ptr});

This function registers a destructor function @var{dest}. The purpose
of the destructor is to free any resources associated with the item
@var{ptr}. The destructor function takes a single argument --- a
pointer to the data being destroyed. All registered destructors are
called in reverse order upon execution of
@code{sieve_machine_destroy()}. Here's a short example of the use
of this function:

@example
@group
static void
free_regex (void *data)
@{
  regfree ((regex_t*)data);        
@}

int
match_part_checker (const char *name, list_t tags, list_t args)
@{
  regex_t *regex;

  /* Initialise the regex: */
  regex = sieve_malloc (mach, sizeof (*regex));
  /* Make sure it will be freed when necessary */
  sieve_machine_add_destructor (sieve_machine, free_regex, regex);
  .
  .
  .
@}
@end group
@end example
@end deftypefn

@deftypefn void *sieve_get_data (sieve_machine_t @var{mach})
This function returns the application-specific data associated with
the instance of sieve machine. See @code{sieve_machine_init()}.
@end deftypefn

@deftypefn message_t sieve_get_message (sieve_machine_t @var{mach})
This function returns the current message.
@end deftypefn

@deftypefn size_t sieve_get_message_num (sieve_machine_t @var{mach});
This function returns the current message number in the mailbox.
If there are no mailbox, i.e. the execution of the sieve code is started
with @code{sieve_message}, this function returns 1.
@end deftypefn

@deftypefn int sieve_get_debug_level (sieve_machine_t @var{mach})
Returns the debug level set for this instance of sieve machine.
@end deftypefn

@deftypefn ticket_t sieve_get_ticket (sieve_machine_t @var{mach})
Returns the authentication ticket for this machine.
@end deftypefn

@deftypefn mailer_t sieve_get_mailer (sieve_machine_t @var{mach})
Returns the mailer.
@end deftypefn

@deftypefn {char *} sieve_get_daemon_email __P((sieve_machine_t @var{mach})
This function returns the @dfn{daemon email} associated with this
instance of sieve machine. The daemon email is an email address used in
envelope from addresses of automatic reply messages. By default it local
part is @samp{<MAILER-DAEMON>} and the domain part is the machine name.
@end deftypefn


@deftypefn void sieve_set_error (sieve_machine_t @var{mach}, sieve_printf_t @var{error_printer})
This function sets the error printer function for the machine. If it is
not set, the default error printer will be used. It is defined as
follows:

@example
int
_sieve_default_error_printer (void *unused, const char *fmt, va_list ap)
@{
  return mu_verror (fmt, ap);
@}
@end example
@end deftypefn

@deftypefn void sieve_set_parse_error (sieve_machine_t @var{mach}, sieve_parse_error_t @var{p})
This function sets the parse error printer function for the machine. If it is
not set, the default parse error printer will be used. It is defined as
follows:

@example
@group
int
_sieve_default_parse_error (void *unused,
                            const char *filename, int lineno,
			    const char *fmt, va_list ap)
@{
  if (filename)
    fprintf (stderr, "%s:%d: ", filename, lineno);
  vfprintf (stderr, fmt, ap);
  fprintf (stderr, "\n");
  return 0;
@}
@end group
@end example
@end deftypefn

@deftypefn void sieve_set_debug (sieve_machine_t @var{mach}, sieve_printf_t @var{debug}));
This function sets the debug printer function for the machine. If it is
not set, the default debug printer is @code{NULL} which means no
debugging information will be displayed.
@end deftypefn

@deftypefn void sieve_set_debug_level (sieve_machine_t @var{mach}, mu_debug_t @var{dbg}, int @var{level})
This function sets the debug level for the given instance of sieve
machine. The @var{dbg} argument is the @code{mu_debug_t} object to be
used with mailutils library, the @var{level} argument specifies the
debugging level for the sieve library itself. It is a bitwise or of
the following values:

@table @code
@item MU_SIEVE_DEBUG_TRACE
Trace the execution of the sieve script.

@item MU_SIEVE_DEBUG_INSTR 
Print the sieve machine instructions as they are executed.

@item MU_SIEVE_DEBUG_DISAS
Dump the disassembled code of the sieve machine. Do not run it.

@item MU_SIEVE_DRY_RUN
Do not executed the actions, only show what would have been done.
@end table
@end deftypefn

@deftypefn void sieve_set_logger (sieve_machine_t @var{mach}, sieve_action_log_t @var{logger})
This function sets the logger function. By default the logger function
is @code{NULL}, which means that the executed actions are not logged.
@end deftypefn

@deftypefn void sieve_set_ticket (sieve_machine_t @var{mach}, ticket_t @var{ticket})
This function sets the authentication ticket to be used with this machine.
@end deftypefn

@deftypefn void sieve_set_mailer (sieve_machine_t @var{mach}, mailer_t @var{mailer})
This function sets the mailer. The default mailer is @code{"sendmail:"}.
@end deftypefn

@deftypefn void sieve_set_daemon_email (sieve_machine_t @var{mach}, const char *@var{email})
This functions sets the @dfn{daemon email} for @code{reject} and
@code{redirect} actions.
@end deftypefn

@deftypefn int sieve_is_dry_run (sieve_machine_t @var{mach})
The @code{sieve_is_dry_run()} returns 1 if the machine is in @dfn{dry
run} state, i.e. it will only log the actions that would have been
executed without actually executing them. The dry run state is set
by calling @code{sieve_set_debug_level()} if its last argument has
the @code{MU_SIEVE_DRY_RUN} bit set.
@end deftypefn

@deftypefn {const char *} sieve_type_str (sieve_data_type @var{type})
Returns the string representation for the given sieve data type. The
return value is a pointer to a static constant string.
@end deftypefn

@node Logging and Diagnostic Functions 
@subsection Logging and Diagnostic Functions 

@deftypefn void sieve_error (sieve_machine_t @var{mach}, const char *@var{fmt}, @dots{})
Format and output an error message using error printer of the machine @var{mach}.
@end deftypefn

@deftypefn void sieve_debug (sieve_machine_t @var{mach}, const char *@var{fmt}, @dots{})
Format and output a debug message using debug printer of the machine @var{mach}.
@end deftypefn

@deftypefn void sieve_log_action (sieve_machine_t @var{mach}, const char *@var{action}, const char *@var{fmt}, @dots{})
Log a sieve action using logger function associated with the machine @var{mach}.
@end deftypefn

@deftypefn void sieve_abort (sieve_machine_t @var{mach})
Immediately abort the execution of the script.
@end deftypefn

@node Symbol Space Functions
@subsection Symbol Space Functions

@deftypefn {sieve_register_t *} sieve_test_lookup (sieve_machine_t @var{mach}, const char *@var{name})
Find a register object describing the test @var{name}. Returns
@code{NULL} if no such test exists.
@end deftypefn

@deftypefn sieve_register_t *sieve_action_lookup (sieve_machine_t @var{mach}, const char *@var{name})
Find a register object describing the action @var{name}. Returns
@code{NULL} if no such action exists.
@end deftypefn
                                           
@deftypefn int sieve_register_test (sieve_machine_t @var{mach}, const char *@var{name}, sieve_handler_t @var{handler}, sieve_data_type *@var{arg_types}, sieve_tag_group_t *@var{tags}, int @var{required})
@end deftypefn
                             
@deftypefn int sieve_register_action (sieve_machine_t @var{mach}, const char *@var{name}, sieve_handler_t @var{handler}, sieve_data_type *@var{arg_types}, sieve_tag_group_t *@var{tags}, int @var{required})
@end deftypefn
                               
@deftypefn int sieve_register_comparator (sieve_machine_t @var{mach}, const char *@var{name}, int @var{required}, sieve_comparator_t @var{is}, sieve_comparator_t @var{contains}, sieve_comparator_t @var{matches}, sieve_comparator_t @var{regex})
@end deftypefn
                                   
@deftypefn int sieve_tag_lookup (list_t @var{taglist}, char *@var{name}, sieve_value_t **@var{arg})
@end deftypefn

@deftypefn int sieve_load_ext (sieve_machine_t @var{mach}, const char *@var{name})
@end deftypefn

@node Memory Allocation
@subsection Memory Allocation

The following functions act as their libc counterparts. The allocated
memory is associated with the @var{mach} argument and is automatically
freed upon the call to @code{sieve_machine_destroy (@var{mach})}.

@deftypefn {void *} sieve_malloc (sieve_machine_t @var{mach}, size_t @var{size})
Allocates @var{size} bytes and returns a pointer to the allocated memory.
@end deftypefn

@deftypefn {char *} sieve_mstrdup (sieve_machine_t @var{mach}, const char *@var{str})
This function returns a pointer to a new string  which is a duplicate of the
string @var{str}.
@end deftypefn

@deftypefn {void *} sieve_mrealloc (sieve_machine_t @var{mach}, void *@var{ptr}, size_t @var{size})
Changes the size of the memory block pointed to by @var{ptr} to
@var{size} bytes.  The contents will be unchanged to the minimum of the
old and new sizes; newly allocated memory will be uninitialized. If
@var{ptr} is @code{NULL}, the call is equivalent to
@code{sieve_malloc(@var{mach}, @var{size})}; if @var{size} is equal to
zero, the call is equivalent to @code{sieve_mfree(@var{ptr})}. Unless
@var{ptr} is @code{NULL}, it must have been returned by an earlier
call to @code{sieve_malloc()} or @code{sieve_mrealloc()}.
@end deftypefn

@deftypefn void sieve_mfree (sieve_machine_t @var{mach}, void *@var{ptr})
@code{sieve_mfree()} frees the memory space pointed to by @var{ptr} and
detaches it from the destructor list of @var{mach}. The @var{ptr} must
have been returned by a previous call to @code{sieve_malloc()} or
@code{sieve_mrealloc()}. Otherwise, or if @code{sieve_mfree(@var{ptr})}
has already been called before, undefined behaviour occurs.

If @var{ptr} is @code{NULL}, no operation is performed.
@end deftypefn

@node Compiling and Executing the Script
@subsection Compiling and Executing the Script

@deftypefn int sieve_compile (sieve_machine_t @var{mach}, const char *@var{name})
Compile the sieve script from the file @var{name}.
@end deftypefn

@deftypefn int sieve_mailbox (sieve_machine_t @var{mach}, mailbox_t @var{mbox})
Execute the code from the given instance of sieve machine @var{mach}
over each message in the mailbox @var{mbox}.
@end deftypefn

@deftypefn int sieve_message (sieve_machine_t @var{mach}, message_t @var{message})
Execute the code from the given instance of sieve machine @var{mach}
over the @var{message}.
@end deftypefn

@deftypefn int sieve_disass (sieve_machine_t @var{mach})
Dump the disassembled code of the sieve machine @var{mach}.
@end deftypefn

@node Input Language
@section Input Language

The input language understood by the @sc{gnu} Sieve Library is a superset of
the Sieve language as described in RFC 3028.

@menu
* Lexical Structure::
* Syntax::
* Preprocessor::
* Require Statement::
* Comparators::
* Tests::
* Actions::
@end menu

@node Lexical Structure
@subsection Lexical Structure

@subheading Whitespace and Comments

Comments are semantically equivalent to whitespace and can be used
anyplace that whitespace is (with one exception in multi-line strings,
as described below).

There are two kinds of comments: hash comments, that begin with a
@samp{#} character that is not contained within a string and continue
until the next newline, and C-style or bracketed comments, that are
delimited by @samp{/*} and @samp{*/} tokens. The bracketed comments
may span multiple lines. E.g.:

@example
if size :over 100K
  @{ # this is a comment
    discard;
  @}
  
if size :over 100K
  @{ /* this is a comment
       this is still a comment */ discard /* this is a comment again
     */ ;
  @}
@end example

Like in C, bracketed comments do not nest.

@subheading Lexical Tokens

The basic lexical entities are @dfn{identifiers} and @dfn{literals}.

An @dfn{identifier} is a sequence of letters, digits and underscores, started
with a letter or underscore. For example, @code{header} and
@code{check_822_again} are valid identifiers, whereas @code{1st} is not.
A special form of identifier is @dfn{tag}: it is an identifier prefixed
with a colon (@samp{:}), e.g.: @code{:comparator}. 

A @dfn{literal} is a data that is not executed, merely evaluated ``as
is'', to be used as arguments to commands. There are four kinds of
literals:

@itemize
@item Number

@dfn{Numbers} are given as ordinary unsigned decimal numbers. An
optional suffix may be used to indicate a multiple of a power of two.
The suffixes are: @samp{K} specifying ``kibi-'', or 1,024 (2^10) times
the value of the number; @samp{M} specifying ``mebi-'', or 1,048,576
(2^20) times the value of the number; and @samp{G} specifying ``tebi-'',
or 1,073,741,824 (2^30) times the value of the number.

The numbers have 32 bits of magnitude.

@item String

A @dfn{string} is any sequence of characters enclosed in double quotes
(@samp{"}). A string cannot contain newlines and double quote
characters. This limitation will disappear in future releases.

@item Multiline Strings

A @dfn{multiline string} is used to represent large blocks of text
with embedded newlines and special characters. It starts with the
keyword @code{text:} followed by a newline and ends with a dot
(@samp{.}) on a newline by itself. Any characters between these two
markers are taken verbatim. For example:

@example
text:
**This is an authomatic response from my message filtering program.**

I can not attend your message right now. However it
will be saved, and I will read it as soon as I am back.

Regards,
Fred
.
@end example

Notice that a hashed comment or whitespace may occur between
@code{text:} and the newline. However, when used inside the multiline
string a hash sign looses its special meaning (except in one case, see
below) and is taken as is, as well as bracketed comment delimiters.
In other words, no comments are allowed within a multiline string. E.g.:
    
@example
text: # This is a comment

Sample text
# This line is taken verbatim
/* And this line too */
.
@end example

The only exception to this rule is that preprocessor @code{include}
statement is expanded as usual when found within a multiline string
(@pxref{#include}), e.g.:

@example
text:
#include <myresponse.txt>
.
@end example

This results in the contents of file @file{myresponse.txt} being read
and interpreted as the contents of the multiline string.

@item String Lists

A @dfn{string list} is a comma-delimited list of quoted strings, enclosed
in a pair of square brackets, e.g.:

@example
["me@@example.com", "me00@@landru.example.edu"]
@end example

For convenience, in any context where a list of strings is appropriate,
a single string is allowed without being a member of a list: it is
equivalent to a list with a single member.  For example, the following
two statements are equivalent:

@example
exists "To";
exists ["To"];
@end example

@end itemize

@node Syntax
@subsection Syntax

Being designed for the sole purpose of filtering mail, Sieve has a very
simple syntax. 

@menu
* Commands::
* Actions Described::
* Control Flow::
* Tests and Conditions::
@end menu

@node Commands
@subsubsection Commands

The basic syntax element is a @dfn{command}. It is defined as follows:

@example
@var{command-name} [@var{tags}] @var{args}
@end example
@noindent
where @var{command-name} is an identifier representing the name of the
command, @var{tags} is an optional list of @dfn{optional} or
@dfn{tagged arguments} and @var{args} is a list of @dfn{required} or
@dfn{positional arguments}.

Positional arguments are literals delimited with whitespace. They
provide the command with the information necessary to its proper
functioning. Each command has a fixed number of positional arguments. It
is an error to supply more arguments to the command or to give it fewer
arguments than it accepts.

Optional arguments allow to modify the behaviour of the command, like
command line options in UNIX do. They are a list of @dfn{tags}
(@pxref{Lexical Structure}) separated by whitespace. An optional
argument may have at most one parameter.

Each command understands a set of optional arguments. Supplying it tags
that it does not understand results in an error.

For example, consider the following command

@example
header :mime :comparator "i;octet" ["to", "from"] "bug-mailutils@@gnu.org"
@end example
@noindent
Here, given that @code{header} takes two positional arguments:
@code{header} is command name, the list @code{["to", "from"]} is first
positional argument and the string @code{"bug-mailutils@@gnu.org"} is second
positional argument. There are two optional arguments: @code{:mime} and
@code{:comparator}. The latter has a string @code{"i;octet"} as its
parameter.

@node Actions Described
@subsubsection Actions Described

An @dfn{action} is a Sieve command that performs some operation over
the message. Actions do the main job in any Sieve
program. Syntactically, an action is a command terminated with
semicolon, e.g.:

@example
keep;

fileinto "mbox";
@end example

@sc{gnu} Sieve provides the full set of actions described in RFC 3028.
It also allows to extend this set using loadable
actions. @xref{Actions}, for detailed discussion of actions.

@node Control Flow
@subsubsection Control Flow

The only control flow statement Sieve has is ``if'' statement. In its
simplest form it is:

@example
if @code{condition} @{ @dots{} @}
@end example

The effect of this statement is that the sequence of actions between the
curly braces is executed only if the @code{condition} evaluates to
@code{true}.

The more elaborate form of this statement allows to execute two
different sets of actions depending on whether the condition is
true or not:

@example
if @code{condition} @{ @dots{} @} else @{ @dots{} @}
@end example

The most advanced form of the ``if'' statement allows to select an
action depending on what condition from the set of conditions is met.

@example
if @code{cond1} @{ @dots{} @} elsif @code{cond2} @{ @dots{} @} else @{ @dots{} @}
@end example

There may be any number of ``elsif'' branches in an ``if''
statement. However it may have at most one ``else'' branch.
Notes for C programmers:

@enumerate
@item The braces surrounding each branch of an ``if'' statement are
required.
@item The ``else if'' construct is disallowed. Use ``elsif'' keyword
instead.
@end enumerate

Here's an example of ``if'' statement:

@example
if header :contains "from" "coyote"
  @{
    discard;
  @}
elsif header :contains ["subject"] ["$$$"]
  @{
    discard;
  @}
else
  @{
    fileinto "INBOX";
  @}
@end example

The following section describes in detail conditions used in ``if''
statements.

@node Tests and Conditions
@subsubsection Tests and Conditions

@dfn{Tests} are Sieve commands that return boolean value. E.g. the
test

@example
header :contains "from" "coyote"
@end example
@noindent
returns true only if the header ``From'' of the current message contains
substring ``coyote''.

The tests shipped with the @sc{gnu} Sieve are described in @ref{Tests}.

@dfn{Condition} is a Sieve expression that evaluates to @code{true} or
@code{false}. In its simplest form, condition is just a Sieve test.

To reverse the sense of a condition use keyword @code{not}, e.g.: 

@example
not header :contains "from" "coyote"
@end example

The results of several conditions may be joined together by logical
@code{and} and @code{or} operations. The special form @code{allof}
takes several tests as its arguments and computes the logical @code{and}
of their results. Similarly, the form @code{anyof} performs logical
@code{or} over the results of its arguments. E.g.:

@example
if anyof (not exists ["From", "Date"],
          header :contains "from" "fool@@example.edu")
  @{
    discard;
  @}
@end example
                   
@node Preprocessor
@subsection Preprocessor
@cindex Sieve preprocessor statements, a @sc{gnu} extension

The preprocessor statements are a @sc{gnu} extension to the Sieve language.
The syntax for a preprocessor statement is similar to that used in
@code{C} programming language, i.e.: a pound character (@samp{#})
followed by a preprocessor directive and its arguments. Any amount of
whitespace can be inserted between the @samp{#} and the directive.
Currently implemented directives are @code{include} and @code{searchpath}.

@menu
* #include::        Include the contents of a file.
* #searchpath::     Modify the current search path.
@end menu

@node #include
@subsubsection Sieve #include directive
@cindex #include, sieve

The @code{#include} directive reads in the contents of the given file.
The contents is ``inserted'' into the text being parsed starting at the
line where the directive appears. The directive takes two forms:

@table @code
@item #include "@var{filename}"
The @var{filename} is taken relative to the current directory.

@item #include <@var{filename}>"
The @var{filename} is searched in the list of include directories
as specified by the @option{-I} command line options.
@end table

If @var{filename} starts with a directory separator character
(@samp{/}) both forms have the same effect.

@node #searchpath
@subsubsection Sieve #searchpath directive
@cindex #searchpath, sieve

The @code{#searchpath} directive adds its argument to the list of
directories searched for loadable modules. It has the same effect
as @option{-L} command line switch used by @sc{gnu} sieve utility
(@pxref{sieve group}). 

@node Require Statement
@subsection Require Statement

@example
Syntax:   require @var{string};
          require @var{string-list};
@end example

The require statement informs the parser that a script makes use of a certain
extension. Multiple capabilities can be declared using the second form
of the statement. The actual handling of a capability name depends on
its suffix.

If the name starts with @samp{comparator-}, it is understood
as a request to use the specified comparator. The comparator name
consists of the characters following the suffix.

If the name starts with @samp{test-}, it means a request to use
the given test. The test name consists of the characters following
the suffix.

Otherwise, the capability is understood as a name of an action to be
used.

The @code{require} statement, if present, must be used before any other
statement that is using the required capability. As an extension, the @sc{gnu}
sieve allows the @code{require} and any other statements to be
interspersed.

By default the following actions and comparators are always required:

@itemize
@item stop
@item keep
@item discard
@item i;octet
@item i;ascii-casemap
@end itemize

Example:

@example
require ["fileinto", "reject"];

require "fileinto";

require "comparator-i;ascii-numeric";
@end example

When processing arguments for @code{require} statement, @sc{gnu} libsieve
uses the following algorithm:

@enumerate 1
@item Look up the name in a symbol table. If the name begins with
@samp{comparator-} it is looked up in the comparator table. If it
begins with @samp{test-}, the test table is used instead. Otherwise
the name is looked up in the action table.

@item If the name is found, the search is terminated.

@item Otherwise, transform the name. First, any @samp{comparator-} or
@samp{test-} prefix is stripped. Then, any character other than
alphanumeric characters, @samp{.} and @samp{,} is replaced with
dash (@samp{-}). The name thus obtained is used as a file name
of an external loadable module. 

@item Try to load the module. The module is searched in the
following search paths (in the order given):

@enumerate 1
@item Mailutils module directory. By default it is
@file{$prefix/lib/mailutils}.

@item Sieve library path as given with the @option{-L} options in
the command line

@item Additional search directories specified with the
@code{#searchpath} directive.

@item The value of the environment variable LTDL_LIBRARY_PATH.

@item System library search path: The system dependent library
search path (e.g. on Linux it is set by the contents of the file
@file{/etc/ld.so.conf} and the value of the environment variable
LD_LIBRARY_PATH).
@end enumerate

The value of LTDL_LIBRARY_PATH and LD_LIBRARY_PATH must be a
colon-separated list of absolute directories, for example,
@samp{"/usr/lib/mypkg:/lib/foo"}.

In any of these directories, @command{libsieve} first attempts to find
and load the given filename. If this fails, it tries to append the
following suffixes to the file name:

@enumerate 1
@item the libtool archive extension @samp{.la}

@item the extension used for native dynamic libraries on the host
platform, e.g., @samp{.so}, @samp{.sl}, etc.
@end enumerate

@item If the module is found, @command{libsieve} executes its
initialization function (see below) and again looks up the name
in the symbol table. If found, search terminates successfully.

@item If either the module is not found, or the symbol wasn't
found after execution of the module initialization function,
search is terminated with an error status. @command{libsieve} then
issues the following diagnostic message:

@example
source for the required action NAME is not available
@end example
@end enumerate

@node Comparators
@subsection Comparators

@sc{gnu} libsieve supports the following built-in comparators:

@table @code
@item i;octet
This comparator simply compares the two arguments octet by octet

@item i;ascii-casemap
It treats uppercase and lowercase characters in the @sc{ascii} subset of
@sc{utf-8} as the same. This is the default comparator.

@item i;ascii-numeric
Treats the two arguments as @sc{ascii} representation of decimal
numbers and compares their numeric values. This comparator must
be explicitly required prior to use.
@end table 

@node Tests
@subsection Tests

This section describes the built-in tests supported by @sc{gnu} libsieve.
In the discussion below the following macro-notations are used:

@table @var
@item match-type
This tag specifies the matching type to be used with the test. It can
be one of the following:

@table @code
@item :is
The @code{:is} match type describes an absolute match; if the contents of
the first string are absolutely the same as the contents of the
second string, they match.  Only the string ``frobnitzm'' is the string
``frobnitzm''.  The null key ``:is'' and only ``:is'' the null value.
This is the default match-type.

@item :contains
The @code{:contains} match type describes a substring match.  If the value
argument contains the key argument as a substring, the match is true.
For instance, the string ``frobnitzm'' contains ``frob'' and ``nit'', but
not ``fbm''.  The null key ``'' is contained in all values.

@item :matches
The @code{:matches} version specifies a wildcard match using the
characters @samp{*} and @samp{?}. @samp{*} matches zero or more
characters, and @samp{?} matches a single character. @samp{?} and
@samp{*} may be escaped as @samp{\\?} and @samp{\\*} in strings to match
against themselves.  The first backslash escapes the second backslash;
together, they escape the @samp{*}.

@item :regex
The @code{:regex} version specifies a match using POSIX Extended Regular
Expressions.
@end table

@item comparator
A @var{comparator} syntax item is defined as follows:

@example
:comparator "@var{comparator-name}"
@end example
@noindent
It instructs sieve to use the given comparator with the test.
If @var{comparator-name} is not one of @samp{i;octet},
@samp{i;ascii-casemap} it must be required prior to using it.
For example:

@example
require "comparator-i;ascii-numeric";

if header :comparator "i;ascii-numeric" :is "X-Num" "10"
  @{
    ...
@end example

@item address-part
This syntax item is used when testing structured Internet addresses. It
specifies which part of an address must be used in comparisons.
Exactly one of the following tags may be used:

@table @code
@item :all
Use the whole address. This is the default.

@item :localpart
Use local part of the address.

@item :domain
Use domain part of the address.
@end table

@end table

@emph{Notice}, that @var{match-type} modifiers interact with
comparators. Some comparators are not suitable for matching with
@code{:contains} or @code{:matches}. If this occurs, sieve issues
an appropriate error message. For example, the statement:

@example
if header :matches :comparator "i;ascii-numeric"
@end example
@noindent
would result in the following error message:

@example
comparator `i;ascii-numeric' is incompatible with match type `:matches'
in call to `header'
@end example

@deffn Test false

This test always evaluates to ``false''.
@end deffn

@deffn Test true

This test always evaluates to ``true''.
@end deffn

@deffn Test address [@var{address-part}][@var{comparator}][@var{match-type}] @var{header-names} @var{key-list}

@noindent
Tagged arguments:

@table @var
@item address-part
Selects the address part to compare. Default is the whole email address
(@code{:all}).

@item comparator
Specifies the comparator to be used instead of the default @code{i;ascii-casemap}.

@item match-type
Specifies the match type to be used instead of the default @code{:is}.
@end table
@noindent
Required arguments:

@table @var
@item header-names
A list of header names.

@item key-list
A list of address values.
@end table
@noindent

The @code{address} test matches Internet addresses in structured headers
that contain addresses.  It returns @code{true} if any header contains any
key in the specified part of the address, as modified by 
@var{comparator} and @var{match-type} optional arguments.

This test returns @code{true} if any combination of the
@var{header-names} and @var{key-list} arguments match.

The @code{address} primitive never acts on the phrase part of an email
address, nor on comments within that address. Use the @code{header} test
instead. It also never acts on group names, although it does act on the
addresses within the group construct.

Example:

@example
if address :is :all "from" "tim@@example.com"
  @{
     discard;
  @} 
@end example
@end deffn

@deffn Test size [:over|:under] @var{number}
@noindent

The @code{size} test deals with the size of a message. The required
argument @var{number} represents the size of the message in bytes. It
may be suffixed with the following quantifiers:

@table @samp
@item k
@itemx K
The number is expressed in kilobytes.
@item m
@itemx M
The number is expressed in megabytes.
@item g
@item G
The number is expressed in gigabytes.
@end table

If the tagged argument is @samp{:over}, and the size of the message is greater
than @var{number}, the test is true; otherwise, it is false.

If the argument is @samp{:under}, and the size of the message is less than
the @var{number}, the test is true; otherwise, it is false.

Otherwise, the test is true only if the size of the message equals
exactly @var{number}. This is a @sc{gnu} extension.

The size of a message is defined to be the number of octets from the
initial header until the last character in the message body.
@end deffn

@deffn Test envelope [@var{address-part}][@var{comparator}][@var{match-type}] @var{envelope-part} @var{key-list}
@noindent

Tagged arguments:

@table @var
@item address-part
Selects the address part to compare. Default is the whole email address
(@code{:all}).

@item comparator
Specifies the comparator to be used instead of the default @code{i;ascii-casemap}.

@item match-type
Specifies the match type to be used instead of the default @code{:is}.
@end table
@noindent
Required arguments:

@table @var
@item envelope-parts
A list of envelope parts to operate upon.

@item key-list
A list of address values.
@end table
@noindent

The @code{envelope} test is true if the specified part of the @sc{smtp}
envelope matches the specified key.

If the envelope-part strings is (case insensitive) @samp{from},
then matching occurs against the FROM address used in the
@command{SMTP MAIL} command.  

@emph{Notice}, that due to the limitations imposed by @sc{smtp} envelope
structure the use of any other values in @var{envelope-parts} header is
meaningless.
@end deffn

@deffn Test exists @var{header-names}
@noindent

Required arguments:

@table @var
@item header-names
List of message header names.
@end table
@sp 1
@noindent

The @code{exists} test is @code{true} if the headers listed in
@var{header-names} argument exist within the message. All of the headers
must exist or the test is false.

The following example throws out mail that doesn't have a From header
and a Date header:

@example
if not exists ["From","Date"]
  @{
     discard;
  @}
@end example
@end deffn

@deffn Test header [@var{comparator}] [@var{match-type}] [:mime] @var{header-names} @var{key-list}
@sp 1
@noindent
Tagged arguments:

@table @asis
@item @var{comparator}
Specifies the comparator to be used instead of the default @code{i;ascii-casemap}.

@item @var{match-type}
Specifies the match type to be used instead of the default @code{:is}.

@item :mime
This tag instructs @code{header} to search through the mime headers in
multipart messages as well.

@end table
@sp 1
@noindent
Required arguments:

@table @var
@item header-names
A list of header names.

@item key-list
A list of header values.
@end table
@sp 1
@noindent
The @code{header} test evaluates to true if any header name matches any
key.  The type of match is specified by the optional match argument,
which defaults to ":is" if not explicitly given.

The test returns @code{true} if any combination of the @var{header-names}
and @var{key-list} arguments match.

If a header listed in @var{header-names} exists, it contains the null
key (@samp{""}).  However, if the named header is not present, it
does not contain the null key.  So if a message contained the header

@example
X-Caffeine: C8H10N4O2
@end example
@sp 1
@noindent
these tests on that header evaluate as follows:

@example 
header :is ["X-Caffeine"] [""] @result{} false
header :contains ["X-Caffeine"] [""] @result{} true
@end example
@end deffn

@deffn Test numaddr [:over|:under] @var{header-names} @var{number}
@noindent
This test is provided as an example of loadable extension tests. You
must use @samp{require "test-numaddr"} statement before actually using
it.

The @code{numaddr} test counts Internet addresses in structured headers
that contain addresses.  It returns true if the total number of
addresses satisfies the requested relation.

If the tagged argument is @samp{:over} and the number of addresses is
greater than @var{number}, the test is true; otherwise, it is false.

If the tagged argument is @samp{:under} and the number of addresses is
less than @var{number}, the test is true; otherwise, it is false.

If the tagged argument is not given, @samp{:over} is assumed. 
@end deffn
        
@node Actions
@subsection Actions

The @sc{gnu} libsieve supports the following default actions:

@itemize
@item stop
@item keep
@item discard
@item fileinto
@item reject
@item redirect
@end itemize

Among them the first three actions do not need to be explicitly required
by a @code{require} statement, while the others do.

These actions are described in detail below.

@deffn Action stop

The @code{stop} action ends all processing. If no actions have been
executed, then the @code{keep} action is taken.
@end deffn

@deffn Action keep

The effect of this action is to preserve the current message in the
mailbox. This action is executed if no other action has been executed.
@end deffn

@deffn Action discard

@code{Discard} silently throws away the current message. No notification
is returned to the sender, the message is deleted from the mailbox.

Example:
@example
if header :contains ["from"] ["idiot@@example.edu"]
  @{
    discard;
  @}
@end example
@end deffn

@deffn Action fileinto @var{folder}
@noindent

Required arguments:

@table @var
@item folder
A string representing the folder name
@end table

The @code{fileinto} action delivers the message into the specified folder.
@end deffn

@deffn Action reject @var{reason}

The optional @code{reject} action refuses delivery of a message by sending
back a message delivery notification to the sender. It resends the
message to the sender, wrapping it in a ``reject'' form, noting that it
was rejected by the recipient. The required argument @var{reason} is
a string specifying the reason for rejecting the message.

Example:

If the message contained
@example
Date: Tue, 1 Apr 1997 09:06:31 -0800 (PST)
From: coyote@@desert.example.org
To: roadrunner@@acme.example.com
Subject: I have a present for you

I've got some great birdseed over here at my place.
Want to buy it?
@end example
@noindent
@sp 1
and the user's script contained:

@example
if header :contains "from" "coyote@@desert.example.org"
  @{
    reject "I am not taking mail from you, and I don't want
            your birdseed, either!";
  @}
@end example
@noindent
then the original sender <coyote@@desert.example.org> would receive the
following notification:

@example
To: <coyote@@desert.example.org>
X-Authentication-Warning: roadrunner set sender using -f flag
Content-Type: multipart/mixed; boundary=----- =_aaaaaaaaaa0
MIME-Version: 1.0
----- =_aaaaaaaaaa0
The original message was received at
Tue, 1 Apr 1997 09:07:15 -0800 from
coyote@@desert.example.org.
Message was refused by recipient's mail filtering program.
Reason given was as follows:

I am not taking mail from you, and I don't want your birdseed, either!

----- =_aaaaaaaaaa0
Content-Type: message/delivery-status

Reporting-UA: sieve; GNU Mailutils 0.1.3
Arrival-Date: Tue, 1 Apr 1997 09:07:15 -0800
Final-Recipient: RFC822; roadrunner@@acme.example.com
Action: deleted
Disposition: automatic-action/MDN-sent-automatically;deleted
Last-Attempt-Date: Tue, 1 Apr 1997 09:07:15 -0800

----- =_aaaaaaaaaa0
Content-Type: message/rfc822

From: coyote@@desert.example.org
To: roadrunner@@acme.example.com
Subject: I have a present for you

I've got some great birdseed over here at my place.
Want to buy it?
----- =_aaaaaaaaaa0
@end example

If the @var{reason} argument is rather long, the common approach is
to use the combination of the @code{text:} and @code{#include} keywords,
e.g.:

@example
if header :mime :matches "Content-Type"
          [ "*application/msword;*", "*audio/x-midi*" ]
  @{
    reject text:
#include "nomsword.txt"
    .
    ;
  @}
@end example      

@end deffn

@deffn Action redirect @var{address}
@noindent

The @code{redirect} action is used to send the message to another user at
a supplied @var{address}, as a mail forwarding feature does.  This action
makes no changes to the message body or existing headers, but it may add
new headers. It also modifies the envelope recipient.

The @code{redirect} command performs an MTA-style ``forward'' --- that
is, what you get from a @file{.forward} file using @code{sendmail} under
@sc{unix}.  The address on the SMTP envelope is replaced with the one on
the @code{redirect} command and the message is sent back
out. @emph{Notice}, that it differs from the MUA-style forward, which
creates a new message with a different sender and message ID, wrapping
the old message in a new one.
@end deffn

@node Extensions
@section Extensions

This section summarizes the @sc{gnu} extensions to the sieve language

@enumerate 1

@item Handling of the @code{require} statement.

@itemize
@item According to the RFC an error must occur if a @code{require} appears
after a command other than @code{require}. The @sc{gnu} sieve library allows
interspersing the @code{require} and other statements. The only
requirement is that @code{require} must occur before a statement that is
using the required capability (@pxref{Require Statement}).

@item Prefixing the required capability with ``test'' requires the use
of an extension test.
@end itemize

@item @code{header} test

The @code{header} takes an optional argument @code{:mime}, meaning to
scan the headers from each part of a multipart message.

@item @code{size} test

The @code{size} test allows to omit the optional argument
(:over|:under). In this case exact equality is assumed.

@item @code{envelope} test

The only value that can be meaningfully used as the first required
argument of an @code{envelope} test is @samp{from}. This limitation
may disappear from the subsequent releases.

@item Match type optional argument.

Along with the usual @code{:is}, @code{:matches} and @code{contains}
matching type, @sc{gnu} sieve library understands @code{:regex} type. This
matching type toggles POSIX Extended Regular Expression matching.

@end enumerate

@node Writing Loadable Commands
@section Writing Loadable Commands

This section contains an example of how to write external loadable
commands for @sc{gnu} libsieve.

@example
@include numaddr.inc
@end example

