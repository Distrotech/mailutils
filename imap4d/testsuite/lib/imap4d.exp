# -*- tcl -*-
# This file is part of Mailutils testsuite.
# Copyright (C) 2002, Free Software Foundation
#  
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#   
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#  
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 

source $top_srcdir/testsuite/lib/mailutils.exp
    
mu_init "--authentication generic --authorization virtdomain"
mu_version
if ![mu_check_capability USE_VIRTUAL_DOMAINS] {
    clone_output "WARNING: Support for virtual domains not compiled in"
    clone_output "WARNING: Skipping tests for imap4d"
    exit 0
}

set IMAP4D_ETC_DIR "$MU_DATA_DIR/etc"

set output [remote_exec host "$MU_MAKESPOOL \
	          -subst \"s,@MU_SPOOL_DIR@,$MU_SPOOL_DIR,\" \
		  $MU_RC_DIR $IMAP4D_ETC_DIR" ]
if [lindex $output 0] {
    perror "Cannot create $IMAP4D_ETC_DIR: [lindex $output 1]"
    exit 1
}
append MU_TOOL_FLAGS " --virtual-passwd-dir $IMAP4D_ETC_DIR \
	 --shared-namespace $MU_DATA_DIR"

set IMAP4D_TAG 0

### Only procedures should come after this point.

proc imap4d_version {} {
    global MU_TOOL
    global MU_TOOL_FLAGS
    global MU_TOOL_VERSION
    
    mu_version
    if ![is_remote host] {
	clone_output "[which $MU_TOOL] version $MU_TOOL_VERSION"
    } else {
	clone_output "$MU_TOOL on remote host version $MU_TOOL_VERSION"
    }
}

proc default_imap4d_start {args} {
    global verbose
    global MU_TOOL
    global MU_TOOL_FLAGS
    global expect_out
    
    mu_version

    set args [lindex $args 0]
    if [info exists MU_TOOL_FLAGS] {
	set sw $MU_TOOL_FLAGS
    } else {
	set sw ""
    }
    
    if [llength $args] {
	append sw $args
    } 
    
    if [info exists host_board] {
	if [board_info $host_board exists top_srcdir] {
	    append sw " --mail-spool [board_info $host_board top_srcdir]/mail/testsuite/spool"
	}
    }

    set imap4d_cmd "$MU_TOOL $sw"
    verbose "Spawning $imap4d_cmd"

    set res [remote_spawn host $imap4d_cmd]
    if { $res < 0 || $res == "" } {
	perror "Spawning $imap4d_cmd failed."
	return 1;
    }

    mu_expect 360 {
	-re "\\* OK IMAP4rev1 Debugging mode.*\r\n" {
	    verbose "imap4d initialized."
	}
	default {
	    perror "imap4d not initialized"
            exit 1
	}
    }
    return 0
}

proc default_imap4d_stop {} {

    verbose "Stopping imap4d"

}

proc imap4d_start {args} {
    global MU_SPOOL_DIR
    
    verbose "Starting pop3d"

    set reuse_spool 0
    for {set i 0} {$i < [llength $args]} {incr i} {
	set a [lindex $args $i]
	if {"$a" == "-reuse-spool"} {
	    set reuse_spool 1
	} else {
	    break;
	}
    }

    if {$reuse_spool == 0} {
	mu_prepare_spools
	set output [remote_exec host \
		         "cp $MU_SPOOL_DIR/teaparty.mbox $MU_SPOOL_DIR/INBOX"]
	if [lindex $output 0] {
		perror "Cannot create $MU_SPOOL_DIR/INBOX: [lindex $output 1]"
		exit 1
	}
    }
    return [default_imap4d_start [concat [lrange $args $i end]]]
}
    
proc imap4d_stop {} {
    return [default_imap4d_stop];
}

##

proc imap4d_make_command { string } {
    global IMAP4D_TAG
    
    incr IMAP4D_TAG
    return "$IMAP4D_TAG $string"
}

proc imap4d_send { string } {
    return [mu_send "$string"]
}

proc imap4d_command { cmd } {
    return [mu_command [imap4d_make_command $cmd]]
}

proc imap4d_exit {} {
    if [imap4d_test "LOGOUT"\
	    "BYE Session terminating." \
	    "OK LOGOUT Completed"] {
	perror "LOGOUT failed"
	exit 1
    }
    return 0
}

proc imap4d_auth {args} {
    set user [lindex $args 0]
    set pass [lindex $args 1]
    if [imap4d_test "LOGIN $user $pass"] {
	perror "Failed to authorize."
	exit 1
    }
}    
    
# imap4d_test [-message MESSAGE][-default (FAIL|XFAIL)]
#            COMMAND [UNTAGGED...][TAGGED]
# COMMAND   - Command to send.
# UNTAGGED  - A list of untagged responses to expect in return. 
# TAGGED    - A tagged response to expect in return. Defaults to "OK"
# MESSAGE   - [optional] message to output
proc imap4d_test { args } {
    global verbose
    global suppress_flag;
    global IMAP4D_TAG
    upvar timeout timeout

    set default ""
    set message ""
    for {set i 0} {$i < [llength $args]} {incr i} {
	set a [lindex $args $i]
	if {"$a" == "-default"} {
	    set default [lindex $args [expr $i + 1]]
	    incr i
	} elseif {"$a" == "-message"} {
	    set message [lindex $args [expr $i + 1]]
	    incr i
	} else {
	    set args [lrange $args $i end]
	    break
	}
    }

    if {"$message" == ""}  {
	set message [lindex $args 0]
    }

    if $verbose>2 then {
	send_user "Message is \"$message\"\n"
    }

    set command [imap4d_make_command [lindex $args 0]]

    set pattern [list]
    set len [expr [llength $args] - 1]

    if {$len >= 2} {
	set regexp 0
	for {set i 1} {$i <= [expr $len - 1]} {incr i} {
	    switch -regexp -- "[lindex $args $i]" {
		-re.*$	-
		--      { set item "[lindex $args $i]"; set regexp 1 }
		default { if {$regexp} {
		              set item "\\* [lindex $args $i]"
		          } else {
			      set item "* [lindex $args $i]"
			  }
			  set regexp 0
		      }
	    }
	    
	    set pattern [concat $pattern [list $item]]
	}
	set tagged [lindex $args end]
    } elseif {$len == 1} {
	set tagged [lindex $args end]
    } else {
	set tagged "OK"
    }

    set pattern [concat $pattern [list "$IMAP4D_TAG $tagged"]]
    set result [mu_test $command $pattern]

    if {$result == 0} {
	pass "$message"
    } elseif {$result == 1} {
	if { "$default" == "" || "$default" != "FAIL" } {
	    fail "$message"
	} else {
	    xfail "$message"
	    set result 0
	}
    } elseif {$result == -2} {
	fail "$message (timeout)"
    } elseif {$result == -3} {
	fail "$message (eof)"
    } else {
	fail "$message"
    }
    return $result
}


