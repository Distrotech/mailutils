README for GNU Mailutils implementation of MH 

The primary aim of this implementation is to provide an interface
between Mailutils and Emacs using mh-e module. 

To use Mailutils MH with Emacs, add the following line to your
site-start.el or .emacs file:

(load "mailutils-mh")

Refer to the file TODO in this directory for information about the
current state of Mailutils MH implementation.


The list of differences between Mailutils and the RAND implementation of MH:

* All programs use usual GNU long options. The support for MH single-dash
options is provided for backward compatibility.

* UUCP addresses are not supported

* Format specifications

** New functions

*** decode
Argument: string
Return: string

Decodes the input string as per RFC 2047. Useful in printing From:,
To: and Subject: headers.

Notice that, unlike the similar NMH function, decode checks the value
of the global profile variable "Charset" to determine the charset
to output the result in. If this variable is not set, decode returns
its argument without any change. If this variable is set to "auto",
decode tries to determine the charset name from the setting of
LC_ALL environment variable. Otherwise, the value of "Charset" is
taken to be the name of the character set.

*** package
Argument: none
Return: string

Returns package name (string "mailutils").

*** package_string
Argument: none
Return: string

Returns full package string (e.g. "GNU Mailutils 2.1")

*** version
Argument: none
Return: string

Returns mailutils version.

*** unre
Argument: string
Return: string

The function removes any leading whitespace and eventual "Re:" prefix
from its argument. Useful for creating subjects in reply messages:

	%<{subject}Subject: Re: %(unre{subject})\\n%>

*** reply_regex
Argument: string
Return: none

Sets the regular expression used to recognize reply messages. The
argument should be a POSIX extended regular expression. The matching
is case insensitive. 

For example, the following invocation

%(reply_regex ^\(re|aw|ang|odp\)\(\\[[0-9]+\\]\)?:[[:blank:]])

corresponds to the English "Re", Polish "Odp", Norwegian "Aw" or
German "Ang", optionally followed by a number in brackets, followed
by colon and any amount of whitespace. Notice the quoting of the
regex metacharacters.

See also `Reply-Regex' and `isreply' below.

*** isreply
Argument: [OPTIONAL] string
Return: boolean

If argument is not given, the value of Subject: header is taken.

The function returns true if its argument matches the "reply subject"
regular expression. This expression is set via the global profile variable
Reply-Regex or via the format function %(reply_regex).

This function is useful for creating Subject: headers in reply
messages. For example, consider the following construction:

%<{subject}%(lit)%<(isreply)%?\
(profile reply-prefix)%(concat)%|%(concat Re:)%>\
%(concat{subject})%(printhdr Subject: )\n%>

If the Subject: header already contained reply prefix, this construct
leaves it unchanged. Otherwise it prepends to it the value of
Reply-Prefix profile variable, or, if it is unset, the string "Re:".

This expression is used in default replcomps and replgroupcomps files.

*** rcpt
Argument: string, one of "to", "cc", "me", "all"
Return: boolean

This function returns true if the given element is present in the
recipient mask (as modified by any --cc and --nocc options) and
false otherwise. It is used in default formats for repl and comp, e.g.:

	%(lit)%<(rcpt to)%(formataddr{to})%>

Notice that this means that usual replcomps file will be ignoring
--cc and --nocc options, unless it has been modified as shown above.

*** concat
Argument: string
Return: none

Appends whitespace + arg to string register.

*** printhdr
Argument: string
Return: none

Prints the value of string register, prefixed by the given
argument. The output is formatted as RFC 822 header, i.e.
it is split at whitespace characters nearest to the width boundary
and each subsequent segment is prefixed with horizontal tabulation.

*** in_reply_to
Argument: none
Return: string

Generates the value for the In-reply-to: header according to RFC 2822.

*** references
Argument: none
Return: string

Generates the value for the References: header according to RFC 2822.

* New profile variables:

** Charset

Controls the character set in which the components decoded via
the `decode' format function should be output (see `decode' above).
By default this variable is not set, which means that no decoding
takes place. If it is set to "auto", `decode' tries to determine
the charset name from the setting of LC_ALL environment variable.
Otherwise, the value of "Charset" is taken to be the name of the
character set.

** Reply-Regex

Sets the regular expression used to recognize reply messages. The
argument should be a POSIX extended regular expression. The matching
is case insensitive. 

For example, setting in your .mh_profile:

Reply-Regex: ^(re|aw|ang|odp)(\[[0-9]+\])?:[[:blank:]]

will make the default replcomps and replgroupcomps formats recognize
usual English, Norwiegian, German and Polish reply subject prefixes.

See also format functions `reply_regex' and `isreply'.

* burst

The utility is able to burst both RFC 934 digest messages and MIME
multipart messages. It provides two additional command line options:
--recurse and --length.

The --recurse option instructs the utility to recursively expand the
digest.

The --length option can be used to set the minimal encapsulation
boundary length for RFC 934 digests. Default length is 1,
i.e. encountering one dash immediately following a newline triggers
digest decoding. It is OK for messages that follow RFC 934
specification. However, many user agents do not precisely follow it,
in particular, they often do not escape lines starting with a dash by
"- " sequence. Mailman is one of such agents. To cope with such
digests you can set encapsulation boundary length to a higher
value. For example, `bounce --length=8' has been found to be
sufficient for most Mailman-generated digests.

* comp

Understands --build option.

* fmtdump command is not provided. Use fmtcheck instead.

* mhl

If the argument to 'ignores' contains more than one component name
it must be enclosed in double-quotes. Dangling equal sign is an error,
to set a string variable to the empty value use = "", e.g.:
overflowtext="" (see the supplied mhl.format file).

Ineractive prompting is not yet implemented.

* mhn

** New option --compose forces mhn editing mode. This is also the default
mode. This differs from the standard mhn, which switches to the
editing mode only if no other options were given and the input file
name coincides with the value of "mhdraft" environment variable. 

** Show mode (--show)
*** If an appropriate mhn-show-type[/subtype] was not found, GNU mhn
prints the decoded message content using moreproc. Standard mhn in
this case used to print "don't know how to display content" diagnostic.

*** The default behaviour is to pipe the content to the standard input
of the mhn-show-type[/subtype] command. This is altered to using a
temporary file if the command contains %f or %F escapes.

** Store mode (--store)
*** If the Content-Disposition header contains "filename=", and mhn
is invoked with --auto switch, it transforms the filename into
the absolute notation and uses it only if it lies below the
current mhn-storage directory. Standard mhn only requires that the
filename do not begin with '/'

*** Before saving a message part, GNU mhn checks if the file already
exists. If so it asks whether the user wishes to rewrite it. This
behaviour is disabled when --quiet option was given.

* mhparam

The -all mode does not display commented out entries.

* repl

Understands --use option. Disposition shell provides 'use' command.

* rmm

** Different behaviour if one of the messages in the list does not exist.

Mailutils rmm does not delete any messages. Standard rmm in this case
deletes all messages preceeding the non-existent one.

** The rmmproc: profile component is not used.

* pick

** The non-standard command line syntax `--FIELD STRING' where `FIELD' is
any string is deprecated. It is recognized only if pick is called from
within another program, so that existing application continue to work.
Please use the following syntax instead: `--component FIELD --pattern STRING'

** New command line option --cflags allows to control the type of 
regular expressions used. The option must occur right before --pattern
or --component option (or one of its aliases, like --cc, --from, etc.)
The argument to this option is a string of type specifications:

    B	     Use basic regular expressions
    E	     Use extended regular expressions
    I	     Ignore case
    C	     Case sensitive.

Default is "EI".

The flags remain in effect until the next occurrence of --cflags
option.

Sample usage:

       pick --cflag BC --subject '*a string' 

** The date comparison options (--before and --after) accept date
specifications in a wide variety of formats, e.g.:

       pick --after 20030301
       pick --after 2003-03-01
       pick --after 01-mar-2003
       pick --after 2003-mar-01
       pick --before '1 year ago'
       etc...

* refile

** Linking messages between folders goes against the logic of Mailutils,
so refile never makes links even if called with --link option. The
latter is actually a synonym for --copy, which preserves the original
message.

** --preserve option is not implemented. It is retained for backward
compatibility only.

** Message specs and folder names may be interspersed.

* sortm

** New option --numfield specifies numeric comparison for the given field.

** Any number of --datefield, --textfield and --numfield options may be
given, thus allowing to build sort criteria of arbitrary complexity.

** The order of --.*field arguments sets the ordering priority. This
differs from the behaviour of the standard sortm, which always orders
datefield-major, textfield-minor.

** Apart from sorting the mailfolder the following actions may be
specified:
 --list     list the ordered messages using a format string given
	    by --form or --format option.
 --dry-run  do not actually sort messages, rather print what would
            have been done. This is useful for debugging purposes.


Local variables:
mode: outline
paragraph-separate: "[ 	]*$"
end:
